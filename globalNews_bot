import requests
import telebot
import time
import threading
import schedule
import feedparser # –¥–ª—è —á—Ç–µ–Ω–∏—è –∏—Ä–ª–∞–Ω–¥—Å–∫–∏—Ö –Ω–æ–≤–æ—Å—Ç–µ–π Met Eireann
from newsapi import NewsApiClient

TOKEN = "*********"
CHAT_ID = "********"
THRESHOLD = 0.01
COINS = ['ethereum', 'bitcoin', 'solana', 'binancecoin', 'cardano', 'ripple']
last_prices = {coin: None for coin in COINS}

bot = telebot.TeleBot(TOKEN)

def get_prices():
    """Fetches current prices and 24h percentage change"""
    ids = ",".join(COINS)
    url = f"https://api.coingecko.com/api/v3/simple/price?ids={ids}&vs_currencies=eur&include_24hr_change=true"
    response = requests.get(url)
    return response.json()

@bot.message_handler(commands=['help', 'start'])
def send_help(message):
    help_text = (
        "ü§ñ **Crypto Analyst Bot Commands:**\n\n"
        "üìà `/status` - Show current prices for all coins\n"
        "üèÜ `/top` - Rank coins by 24h performance\n"
        "‚è∞ *Daily Summary* - Sent automatically at 08:00\n"
        "üì¢ *Alerts* - I'll notify you if a coin moves > 1%"
    )
    bot.reply_to(message, help_text, parse_mode="Markdown")

@bot.message_handler(commands=['top'])
def send_top(message):
    try:
        data = get_prices()
        # Sort coins by the 24h change percentage (descending)
        sorted_coins = sorted(
            COINS,
            key=lambda x: data[x].get('eur_24h_change', 0),
            reverse=True
        )

        text = "üèÜ **24h Performance Ranking:**\n\n"
        for i, coin in enumerate(sorted_coins, 1):
            change = round(data[coin]['eur_24h_change'], 2)
            emoji = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else "üîπ"
            text += f"{emoji} {coin.capitalize()}: {change}%\n"

        bot.reply_to(message, text, parse_mode="Markdown")
    except Exception as e:
        print(f"Error fetching data: {e}")
        bot.reply_to(message, "‚ùå Could not rank coins right now.")


def send_daily_summary():
    """Function to send a report once a day"""
    try:
        data = get_prices()
        summary = "‚òï **Good Morning! Your Daily Crypto Report:**\n\n"
        for coin in COINS:
            price = data[coin]['eur']
            change_24h = round(data[coin]['eur_24h_change'], 2)
            emoji = "üü¢" if change_24h > 0 else "üî¥"
            summary += f"{emoji} {coin.capitalize()}: {price} EUR ({change_24h}% 24h)\n"

        bot.send_message(CHAT_ID, summary, parse_mode="Markdown")
        print("Daily summary sent!")
    except Exception as e:
        print(f"Error sending summary: {e}")


def price_tracker():
    print("Multi-coin analyst started...")
    while True:
        try:
            data = get_prices()
            for coin in COINS:
                current_price = data[coin]['eur']
                if last_prices[coin] is None:
                    last_prices[coin] = current_price
                    continue

                change = (current_price - last_prices[coin]) / last_prices[coin]

                if abs(change) >= THRESHOLD:
                    direction = "üìà" if change > 0 else "üìâ"
                    percent = round(change * 100, 2)
                    msg = f"{direction} **{coin.upper()}** {percent}%\nPrice: {current_price} EUR"
                    bot.send_message(CHAT_ID, msg, parse_mode="Markdown")
                    last_prices[coin] = current_price

            time.sleep(600)
        except Exception as e:
            print(f"Tracker Error: {e}")
            time.sleep(60)

@bot.message_handler(commands=['status'])
def send_status(message):
    try:
        data = get_prices()
        text = "üìä **Current Prices:**\n"
        for coin in COINS:
            p = data[coin]['eur']
            text += f"‚Ä¢ {coin.capitalize()}: {p} EUR\n"
        bot.reply_to(message, text, parse_mode="Markdown")
    except Exception as e:
        print(f"Error fetching data: {e}")
        bot.reply_to(message, "Error fetching data.")

NEWS_API_KEY = "**********"
newsapi = NewsApiClient(api_key=NEWS_API_KEY)

def get_world_news():
    # –ë–µ—Ä–µ–º —Ç–æ–ø-10 –º–∏—Ä–æ–≤—ã—Ö –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º
    top_headlines = newsapi.get_top_headlines(language='en', page_size=10)
    titles = [art['title'] for art in top_headlines['articles']]
    return titles

def get_earthquakes():
    # –ó–∞–ø—Ä–æ—Å –∫ USGS: –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏—è –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞ –º–∞–≥–Ω–∏—Ç—É–¥–æ–π 5.0+
    url = "https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&minmagnitude=5"
    resp = requests.get(url).json()
    quakes = []
    for feature in resp['features'][:3]: # –≤–æ–∑—å–º–µ–º —Ç–æ–ø-3 —Å–∞–º—ã—Ö —Å–∏–ª—å–Ω—ã—Ö
        place = feature['properties']['place']
        mag = feature['properties']['mag']
        quakes.append(f"üåç –ó–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–µ: {place} (M {mag})")
    return quakes

def get_ireland_alerts():
    # –ß–∏—Ç–∞–µ–º RSS —Ñ–∏–¥ –ø–æ–≥–æ–¥–Ω—ã—Ö –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –ò—Ä–ª–∞–Ω–¥–∏–∏
    feed = feedparser.parse("https://www.met.ie/warningsxml/rss.xml")
    alerts = []
    if feed.entries:
        for entry in feed.entries[:2]:
            alerts.append(f"üáÆüá™ Ireland Alert: {entry.title}")
    else:
        alerts.append("üáÆüá™ –í –ò—Ä–ª–∞–Ω–¥–∏–∏ –≤—Å—ë —Å–ø–æ–∫–æ–π–Ω–æ.")
    return alerts

def send_evening_summary(bot, chat_id):
    news = get_world_news()
    quakes = get_earthquakes()
    ireland = get_ireland_alerts()

    report = "üìú **–ò–¢–û–ì–ò –î–ù–Ø: GLOBAL INTELLIGENCE**\n\n"
    report += "üîù **–¢–û–ü 10 –ù–û–í–û–°–¢–ï–ô:**\n" + "\n".join([f"- {n}" for n in news]) + "\n\n"
    report += "üåã **–ö–õ–ò–ú–ê–¢ (–ó–ï–ú–õ–ï–¢–†–Ø–°–ï–ù–ò–Ø 5.0+):**\n" + "\n".join(quakes) + "\n\n"
    report += "üåä **–ò–†–õ–ê–ù–î–ò–Ø –ò –í–û–î–ê:**\n" + "\n".join(ireland)

    bot.send_message(chat_id, report)


def run_scheduler():
    """Background thread for the clock"""
    # Change '08:00' to whatever time you want the report
    schedule.every().day.at("08:00").do(send_daily_summary)
    schedule.every().day.at("21:00").do(send_evening_summary)

    while True:
        schedule.run_pending()
        time.sleep(60)

if __name__ == "__main__":
    threading.Thread(target=run_scheduler, daemon=True).start()
    threading.Thread(target=price_tracker, daemon=True).start()
    print("All systems running with /top command active...")
    bot.infinity_polling()
